// source: proto/scheduler.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof window !== 'undefined' && window) ||
    (typeof global !== 'undefined' && global) ||
    (typeof self !== 'undefined' && self) ||
    (function () { return this; }).call(null) ||
    Function('return this')();

var google_rpc_status_pb = require('../google/rpc/status_pb.js');
goog.object.extend(proto, google_rpc_status_pb);
var google_protobuf_timestamp_pb = require('google-protobuf/google/protobuf/timestamp_pb.js');
goog.object.extend(proto, google_protobuf_timestamp_pb);
var proto_acl_pb = require('../proto/acl_pb.js');
goog.object.extend(proto, proto_acl_pb);
var proto_context_pb = require('../proto/context_pb.js');
goog.object.extend(proto, proto_context_pb);
var proto_trace_pb = require('../proto/trace_pb.js');
goog.object.extend(proto, proto_trace_pb);
goog.exportSymbol('proto.scheduler.EnqueueTaskReservationRequest', null, global);
goog.exportSymbol('proto.scheduler.EnqueueTaskReservationResponse', null, global);
goog.exportSymbol('proto.scheduler.ExecutionNode', null, global);
goog.exportSymbol('proto.scheduler.GetExecutionNodesRequest', null, global);
goog.exportSymbol('proto.scheduler.GetExecutionNodesResponse', null, global);
goog.exportSymbol('proto.scheduler.GetExecutionNodesResponse.Executor', null, global);
goog.exportSymbol('proto.scheduler.LeaseTaskRequest', null, global);
goog.exportSymbol('proto.scheduler.LeaseTaskResponse', null, global);
goog.exportSymbol('proto.scheduler.NodeAddress', null, global);
goog.exportSymbol('proto.scheduler.ReEnqueueTaskRequest', null, global);
goog.exportSymbol('proto.scheduler.ReEnqueueTaskResponse', null, global);
goog.exportSymbol('proto.scheduler.RegisterAndStreamWorkRequest', null, global);
goog.exportSymbol('proto.scheduler.RegisterAndStreamWorkResponse', null, global);
goog.exportSymbol('proto.scheduler.RegisterExecutorRequest', null, global);
goog.exportSymbol('proto.scheduler.RegisteredExecutionNode', null, global);
goog.exportSymbol('proto.scheduler.ScheduleTaskRequest', null, global);
goog.exportSymbol('proto.scheduler.ScheduleTaskResponse', null, global);
goog.exportSymbol('proto.scheduler.SchedulingMetadata', null, global);
goog.exportSymbol('proto.scheduler.ShuttingDownRequest', null, global);
goog.exportSymbol('proto.scheduler.TaskSize', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.NodeAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.NodeAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.NodeAddress.displayName = 'proto.scheduler.NodeAddress';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.LeaseTaskRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.LeaseTaskRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.LeaseTaskRequest.displayName = 'proto.scheduler.LeaseTaskRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.LeaseTaskResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.LeaseTaskResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.LeaseTaskResponse.displayName = 'proto.scheduler.LeaseTaskResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.TaskSize = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.TaskSize, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.TaskSize.displayName = 'proto.scheduler.TaskSize';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.SchedulingMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.SchedulingMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.SchedulingMetadata.displayName = 'proto.scheduler.SchedulingMetadata';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ScheduleTaskRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.ScheduleTaskRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ScheduleTaskRequest.displayName = 'proto.scheduler.ScheduleTaskRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ScheduleTaskResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.ScheduleTaskResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ScheduleTaskResponse.displayName = 'proto.scheduler.ScheduleTaskResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ReEnqueueTaskRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.ReEnqueueTaskRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ReEnqueueTaskRequest.displayName = 'proto.scheduler.ReEnqueueTaskRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ReEnqueueTaskResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.ReEnqueueTaskResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ReEnqueueTaskResponse.displayName = 'proto.scheduler.ReEnqueueTaskResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.EnqueueTaskReservationRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.EnqueueTaskReservationRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.EnqueueTaskReservationRequest.displayName = 'proto.scheduler.EnqueueTaskReservationRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.EnqueueTaskReservationResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.EnqueueTaskReservationResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.EnqueueTaskReservationResponse.displayName = 'proto.scheduler.EnqueueTaskReservationResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.RegisterExecutorRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.RegisterExecutorRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.RegisterExecutorRequest.displayName = 'proto.scheduler.RegisterExecutorRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ShuttingDownRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.scheduler.ShuttingDownRequest.repeatedFields_, null);
};
goog.inherits(proto.scheduler.ShuttingDownRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ShuttingDownRequest.displayName = 'proto.scheduler.ShuttingDownRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.RegisterAndStreamWorkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.RegisterAndStreamWorkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.RegisterAndStreamWorkRequest.displayName = 'proto.scheduler.RegisterAndStreamWorkRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.RegisterAndStreamWorkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.RegisterAndStreamWorkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.RegisterAndStreamWorkResponse.displayName = 'proto.scheduler.RegisterAndStreamWorkResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.ExecutionNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.ExecutionNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.ExecutionNode.displayName = 'proto.scheduler.ExecutionNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.GetExecutionNodesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.GetExecutionNodesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.GetExecutionNodesRequest.displayName = 'proto.scheduler.GetExecutionNodesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.GetExecutionNodesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.scheduler.GetExecutionNodesResponse.repeatedFields_, null);
};
goog.inherits(proto.scheduler.GetExecutionNodesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.GetExecutionNodesResponse.displayName = 'proto.scheduler.GetExecutionNodesResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.GetExecutionNodesResponse.Executor = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.GetExecutionNodesResponse.Executor, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.GetExecutionNodesResponse.Executor.displayName = 'proto.scheduler.GetExecutionNodesResponse.Executor';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.scheduler.RegisteredExecutionNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.scheduler.RegisteredExecutionNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.scheduler.RegisteredExecutionNode.displayName = 'proto.scheduler.RegisteredExecutionNode';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.NodeAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.NodeAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.NodeAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.NodeAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    host: jspb.Message.getFieldWithDefault(msg, 1, ""),
    port: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.NodeAddress}
 */
proto.scheduler.NodeAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.NodeAddress;
  return proto.scheduler.NodeAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.NodeAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.NodeAddress}
 */
proto.scheduler.NodeAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setHost(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPort(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.NodeAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.NodeAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.NodeAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.NodeAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHost();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPort();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional string host = 1;
 * @return {string}
 */
proto.scheduler.NodeAddress.prototype.getHost = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.NodeAddress} returns this
 */
proto.scheduler.NodeAddress.prototype.setHost = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int32 port = 2;
 * @return {number}
 */
proto.scheduler.NodeAddress.prototype.getPort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.NodeAddress} returns this
 */
proto.scheduler.NodeAddress.prototype.setPort = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.LeaseTaskRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.LeaseTaskRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.LeaseTaskRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.LeaseTaskRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    finalize: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    release: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    executorId: jspb.Message.getFieldWithDefault(msg, 4, ""),
    reEnqueue: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
    reEnqueueReason: (f = msg.getReEnqueueReason()) && google_rpc_status_pb.Status.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.LeaseTaskRequest}
 */
proto.scheduler.LeaseTaskRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.LeaseTaskRequest;
  return proto.scheduler.LeaseTaskRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.LeaseTaskRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.LeaseTaskRequest}
 */
proto.scheduler.LeaseTaskRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFinalize(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRelease(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutorId(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setReEnqueue(value);
      break;
    case 6:
      var value = new google_rpc_status_pb.Status;
      reader.readMessage(value,google_rpc_status_pb.Status.deserializeBinaryFromReader);
      msg.setReEnqueueReason(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.LeaseTaskRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.LeaseTaskRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.LeaseTaskRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.LeaseTaskRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFinalize();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRelease();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getExecutorId();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getReEnqueue();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getReEnqueueReason();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      google_rpc_status_pb.Status.serializeBinaryToWriter
    );
  }
};


/**
 * optional string task_id = 1;
 * @return {string}
 */
proto.scheduler.LeaseTaskRequest.prototype.getTaskId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.setTaskId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool finalize = 2;
 * @return {boolean}
 */
proto.scheduler.LeaseTaskRequest.prototype.getFinalize = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.setFinalize = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool release = 3;
 * @return {boolean}
 */
proto.scheduler.LeaseTaskRequest.prototype.getRelease = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.setRelease = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional string executor_id = 4;
 * @return {string}
 */
proto.scheduler.LeaseTaskRequest.prototype.getExecutorId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.setExecutorId = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional bool re_enqueue = 5;
 * @return {boolean}
 */
proto.scheduler.LeaseTaskRequest.prototype.getReEnqueue = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 5, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.setReEnqueue = function(value) {
  return jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional google.rpc.Status re_enqueue_reason = 6;
 * @return {?proto.google.rpc.Status}
 */
proto.scheduler.LeaseTaskRequest.prototype.getReEnqueueReason = function() {
  return /** @type{?proto.google.rpc.Status} */ (
    jspb.Message.getWrapperField(this, google_rpc_status_pb.Status, 6));
};


/**
 * @param {?proto.google.rpc.Status|undefined} value
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
*/
proto.scheduler.LeaseTaskRequest.prototype.setReEnqueueReason = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.LeaseTaskRequest} returns this
 */
proto.scheduler.LeaseTaskRequest.prototype.clearReEnqueueReason = function() {
  return this.setReEnqueueReason(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.LeaseTaskRequest.prototype.hasReEnqueueReason = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.LeaseTaskResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.LeaseTaskResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.LeaseTaskResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.LeaseTaskResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    serializedTask: msg.getSerializedTask_asB64(),
    leaseDurationSeconds: jspb.Message.getFieldWithDefault(msg, 2, 0),
    closedCleanly: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.LeaseTaskResponse}
 */
proto.scheduler.LeaseTaskResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.LeaseTaskResponse;
  return proto.scheduler.LeaseTaskResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.LeaseTaskResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.LeaseTaskResponse}
 */
proto.scheduler.LeaseTaskResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTask(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLeaseDurationSeconds(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setClosedCleanly(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.LeaseTaskResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.LeaseTaskResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.LeaseTaskResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.LeaseTaskResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSerializedTask_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getLeaseDurationSeconds();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getClosedCleanly();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional bytes serialized_task = 1;
 * @return {!(string|Uint8Array)}
 */
proto.scheduler.LeaseTaskResponse.prototype.getSerializedTask = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes serialized_task = 1;
 * This is a type-conversion wrapper around `getSerializedTask()`
 * @return {string}
 */
proto.scheduler.LeaseTaskResponse.prototype.getSerializedTask_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTask()));
};


/**
 * optional bytes serialized_task = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTask()`
 * @return {!Uint8Array}
 */
proto.scheduler.LeaseTaskResponse.prototype.getSerializedTask_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTask()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.scheduler.LeaseTaskResponse} returns this
 */
proto.scheduler.LeaseTaskResponse.prototype.setSerializedTask = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional int64 lease_duration_seconds = 2;
 * @return {number}
 */
proto.scheduler.LeaseTaskResponse.prototype.getLeaseDurationSeconds = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.LeaseTaskResponse} returns this
 */
proto.scheduler.LeaseTaskResponse.prototype.setLeaseDurationSeconds = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bool closed_cleanly = 3;
 * @return {boolean}
 */
proto.scheduler.LeaseTaskResponse.prototype.getClosedCleanly = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.LeaseTaskResponse} returns this
 */
proto.scheduler.LeaseTaskResponse.prototype.setClosedCleanly = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.TaskSize.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.TaskSize.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.TaskSize} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.TaskSize.toObject = function(includeInstance, msg) {
  var f, obj = {
    estimatedMemoryBytes: jspb.Message.getFieldWithDefault(msg, 1, 0),
    estimatedMilliCpu: jspb.Message.getFieldWithDefault(msg, 2, 0),
    estimatedFreeDiskBytes: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.TaskSize}
 */
proto.scheduler.TaskSize.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.TaskSize;
  return proto.scheduler.TaskSize.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.TaskSize} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.TaskSize}
 */
proto.scheduler.TaskSize.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setEstimatedMemoryBytes(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setEstimatedMilliCpu(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setEstimatedFreeDiskBytes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.TaskSize.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.TaskSize.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.TaskSize} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.TaskSize.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEstimatedMemoryBytes();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getEstimatedMilliCpu();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getEstimatedFreeDiskBytes();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional int64 estimated_memory_bytes = 1;
 * @return {number}
 */
proto.scheduler.TaskSize.prototype.getEstimatedMemoryBytes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.TaskSize} returns this
 */
proto.scheduler.TaskSize.prototype.setEstimatedMemoryBytes = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional int64 estimated_milli_cpu = 2;
 * @return {number}
 */
proto.scheduler.TaskSize.prototype.getEstimatedMilliCpu = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.TaskSize} returns this
 */
proto.scheduler.TaskSize.prototype.setEstimatedMilliCpu = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 estimated_free_disk_bytes = 3;
 * @return {number}
 */
proto.scheduler.TaskSize.prototype.getEstimatedFreeDiskBytes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.TaskSize} returns this
 */
proto.scheduler.TaskSize.prototype.setEstimatedFreeDiskBytes = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.SchedulingMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.SchedulingMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.SchedulingMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.SchedulingMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskSize: (f = msg.getTaskSize()) && proto.scheduler.TaskSize.toObject(includeInstance, f),
    measuredTaskSize: (f = msg.getMeasuredTaskSize()) && proto.scheduler.TaskSize.toObject(includeInstance, f),
    predictedTaskSize: (f = msg.getPredictedTaskSize()) && proto.scheduler.TaskSize.toObject(includeInstance, f),
    os: jspb.Message.getFieldWithDefault(msg, 2, ""),
    arch: jspb.Message.getFieldWithDefault(msg, 3, ""),
    pool: jspb.Message.getFieldWithDefault(msg, 4, ""),
    executorGroupId: jspb.Message.getFieldWithDefault(msg, 5, ""),
    taskGroupId: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.SchedulingMetadata}
 */
proto.scheduler.SchedulingMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.SchedulingMetadata;
  return proto.scheduler.SchedulingMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.SchedulingMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.SchedulingMetadata}
 */
proto.scheduler.SchedulingMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.scheduler.TaskSize;
      reader.readMessage(value,proto.scheduler.TaskSize.deserializeBinaryFromReader);
      msg.setTaskSize(value);
      break;
    case 7:
      var value = new proto.scheduler.TaskSize;
      reader.readMessage(value,proto.scheduler.TaskSize.deserializeBinaryFromReader);
      msg.setMeasuredTaskSize(value);
      break;
    case 8:
      var value = new proto.scheduler.TaskSize;
      reader.readMessage(value,proto.scheduler.TaskSize.deserializeBinaryFromReader);
      msg.setPredictedTaskSize(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setOs(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setArch(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPool(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutorGroupId(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskGroupId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.SchedulingMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.SchedulingMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.SchedulingMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.SchedulingMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskSize();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.scheduler.TaskSize.serializeBinaryToWriter
    );
  }
  f = message.getMeasuredTaskSize();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.scheduler.TaskSize.serializeBinaryToWriter
    );
  }
  f = message.getPredictedTaskSize();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.scheduler.TaskSize.serializeBinaryToWriter
    );
  }
  f = message.getOs();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getArch();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getPool();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getExecutorGroupId();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getTaskGroupId();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional TaskSize task_size = 1;
 * @return {?proto.scheduler.TaskSize}
 */
proto.scheduler.SchedulingMetadata.prototype.getTaskSize = function() {
  return /** @type{?proto.scheduler.TaskSize} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.TaskSize, 1));
};


/**
 * @param {?proto.scheduler.TaskSize|undefined} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
*/
proto.scheduler.SchedulingMetadata.prototype.setTaskSize = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.clearTaskSize = function() {
  return this.setTaskSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.SchedulingMetadata.prototype.hasTaskSize = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TaskSize measured_task_size = 7;
 * @return {?proto.scheduler.TaskSize}
 */
proto.scheduler.SchedulingMetadata.prototype.getMeasuredTaskSize = function() {
  return /** @type{?proto.scheduler.TaskSize} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.TaskSize, 7));
};


/**
 * @param {?proto.scheduler.TaskSize|undefined} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
*/
proto.scheduler.SchedulingMetadata.prototype.setMeasuredTaskSize = function(value) {
  return jspb.Message.setWrapperField(this, 7, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.clearMeasuredTaskSize = function() {
  return this.setMeasuredTaskSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.SchedulingMetadata.prototype.hasMeasuredTaskSize = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional TaskSize predicted_task_size = 8;
 * @return {?proto.scheduler.TaskSize}
 */
proto.scheduler.SchedulingMetadata.prototype.getPredictedTaskSize = function() {
  return /** @type{?proto.scheduler.TaskSize} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.TaskSize, 8));
};


/**
 * @param {?proto.scheduler.TaskSize|undefined} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
*/
proto.scheduler.SchedulingMetadata.prototype.setPredictedTaskSize = function(value) {
  return jspb.Message.setWrapperField(this, 8, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.clearPredictedTaskSize = function() {
  return this.setPredictedTaskSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.SchedulingMetadata.prototype.hasPredictedTaskSize = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional string os = 2;
 * @return {string}
 */
proto.scheduler.SchedulingMetadata.prototype.getOs = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.setOs = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string arch = 3;
 * @return {string}
 */
proto.scheduler.SchedulingMetadata.prototype.getArch = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.setArch = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string pool = 4;
 * @return {string}
 */
proto.scheduler.SchedulingMetadata.prototype.getPool = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.setPool = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string executor_group_id = 5;
 * @return {string}
 */
proto.scheduler.SchedulingMetadata.prototype.getExecutorGroupId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.setExecutorGroupId = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string task_group_id = 6;
 * @return {string}
 */
proto.scheduler.SchedulingMetadata.prototype.getTaskGroupId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.SchedulingMetadata} returns this
 */
proto.scheduler.SchedulingMetadata.prototype.setTaskGroupId = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ScheduleTaskRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ScheduleTaskRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ScheduleTaskRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ScheduleTaskRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    metadata: (f = msg.getMetadata()) && proto.scheduler.SchedulingMetadata.toObject(includeInstance, f),
    serializedTask: msg.getSerializedTask_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ScheduleTaskRequest}
 */
proto.scheduler.ScheduleTaskRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ScheduleTaskRequest;
  return proto.scheduler.ScheduleTaskRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ScheduleTaskRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ScheduleTaskRequest}
 */
proto.scheduler.ScheduleTaskRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskId(value);
      break;
    case 2:
      var value = new proto.scheduler.SchedulingMetadata;
      reader.readMessage(value,proto.scheduler.SchedulingMetadata.deserializeBinaryFromReader);
      msg.setMetadata(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTask(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ScheduleTaskRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ScheduleTaskRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ScheduleTaskRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ScheduleTaskRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMetadata();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.scheduler.SchedulingMetadata.serializeBinaryToWriter
    );
  }
  f = message.getSerializedTask_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string task_id = 1;
 * @return {string}
 */
proto.scheduler.ScheduleTaskRequest.prototype.getTaskId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ScheduleTaskRequest} returns this
 */
proto.scheduler.ScheduleTaskRequest.prototype.setTaskId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional SchedulingMetadata metadata = 2;
 * @return {?proto.scheduler.SchedulingMetadata}
 */
proto.scheduler.ScheduleTaskRequest.prototype.getMetadata = function() {
  return /** @type{?proto.scheduler.SchedulingMetadata} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.SchedulingMetadata, 2));
};


/**
 * @param {?proto.scheduler.SchedulingMetadata|undefined} value
 * @return {!proto.scheduler.ScheduleTaskRequest} returns this
*/
proto.scheduler.ScheduleTaskRequest.prototype.setMetadata = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.ScheduleTaskRequest} returns this
 */
proto.scheduler.ScheduleTaskRequest.prototype.clearMetadata = function() {
  return this.setMetadata(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.ScheduleTaskRequest.prototype.hasMetadata = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes serialized_task = 3;
 * @return {!(string|Uint8Array)}
 */
proto.scheduler.ScheduleTaskRequest.prototype.getSerializedTask = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes serialized_task = 3;
 * This is a type-conversion wrapper around `getSerializedTask()`
 * @return {string}
 */
proto.scheduler.ScheduleTaskRequest.prototype.getSerializedTask_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTask()));
};


/**
 * optional bytes serialized_task = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTask()`
 * @return {!Uint8Array}
 */
proto.scheduler.ScheduleTaskRequest.prototype.getSerializedTask_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTask()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.scheduler.ScheduleTaskRequest} returns this
 */
proto.scheduler.ScheduleTaskRequest.prototype.setSerializedTask = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ScheduleTaskResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ScheduleTaskResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ScheduleTaskResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ScheduleTaskResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ScheduleTaskResponse}
 */
proto.scheduler.ScheduleTaskResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ScheduleTaskResponse;
  return proto.scheduler.ScheduleTaskResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ScheduleTaskResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ScheduleTaskResponse}
 */
proto.scheduler.ScheduleTaskResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ScheduleTaskResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ScheduleTaskResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ScheduleTaskResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ScheduleTaskResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ReEnqueueTaskRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ReEnqueueTaskRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ReEnqueueTaskRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    reason: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ReEnqueueTaskRequest}
 */
proto.scheduler.ReEnqueueTaskRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ReEnqueueTaskRequest;
  return proto.scheduler.ReEnqueueTaskRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ReEnqueueTaskRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ReEnqueueTaskRequest}
 */
proto.scheduler.ReEnqueueTaskRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setReason(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ReEnqueueTaskRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ReEnqueueTaskRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ReEnqueueTaskRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getReason();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string task_id = 1;
 * @return {string}
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.getTaskId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ReEnqueueTaskRequest} returns this
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.setTaskId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string reason = 2;
 * @return {string}
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.getReason = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ReEnqueueTaskRequest} returns this
 */
proto.scheduler.ReEnqueueTaskRequest.prototype.setReason = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ReEnqueueTaskResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ReEnqueueTaskResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ReEnqueueTaskResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ReEnqueueTaskResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ReEnqueueTaskResponse}
 */
proto.scheduler.ReEnqueueTaskResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ReEnqueueTaskResponse;
  return proto.scheduler.ReEnqueueTaskResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ReEnqueueTaskResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ReEnqueueTaskResponse}
 */
proto.scheduler.ReEnqueueTaskResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ReEnqueueTaskResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ReEnqueueTaskResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ReEnqueueTaskResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ReEnqueueTaskResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.EnqueueTaskReservationRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.EnqueueTaskReservationRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.EnqueueTaskReservationRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    taskSize: (f = msg.getTaskSize()) && proto.scheduler.TaskSize.toObject(includeInstance, f),
    schedulingMetadata: (f = msg.getSchedulingMetadata()) && proto.scheduler.SchedulingMetadata.toObject(includeInstance, f),
    executorId: jspb.Message.getFieldWithDefault(msg, 4, ""),
    traceMetadata: (f = msg.getTraceMetadata()) && proto_trace_pb.Metadata.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.EnqueueTaskReservationRequest}
 */
proto.scheduler.EnqueueTaskReservationRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.EnqueueTaskReservationRequest;
  return proto.scheduler.EnqueueTaskReservationRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.EnqueueTaskReservationRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.EnqueueTaskReservationRequest}
 */
proto.scheduler.EnqueueTaskReservationRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskId(value);
      break;
    case 2:
      var value = new proto.scheduler.TaskSize;
      reader.readMessage(value,proto.scheduler.TaskSize.deserializeBinaryFromReader);
      msg.setTaskSize(value);
      break;
    case 3:
      var value = new proto.scheduler.SchedulingMetadata;
      reader.readMessage(value,proto.scheduler.SchedulingMetadata.deserializeBinaryFromReader);
      msg.setSchedulingMetadata(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutorId(value);
      break;
    case 100:
      var value = new proto_trace_pb.Metadata;
      reader.readMessage(value,proto_trace_pb.Metadata.deserializeBinaryFromReader);
      msg.setTraceMetadata(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.EnqueueTaskReservationRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.EnqueueTaskReservationRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.EnqueueTaskReservationRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTaskSize();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.scheduler.TaskSize.serializeBinaryToWriter
    );
  }
  f = message.getSchedulingMetadata();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.scheduler.SchedulingMetadata.serializeBinaryToWriter
    );
  }
  f = message.getExecutorId();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getTraceMetadata();
  if (f != null) {
    writer.writeMessage(
      100,
      f,
      proto_trace_pb.Metadata.serializeBinaryToWriter
    );
  }
};


/**
 * optional string task_id = 1;
 * @return {string}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.getTaskId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.setTaskId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional TaskSize task_size = 2;
 * @return {?proto.scheduler.TaskSize}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.getTaskSize = function() {
  return /** @type{?proto.scheduler.TaskSize} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.TaskSize, 2));
};


/**
 * @param {?proto.scheduler.TaskSize|undefined} value
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
*/
proto.scheduler.EnqueueTaskReservationRequest.prototype.setTaskSize = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.clearTaskSize = function() {
  return this.setTaskSize(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.hasTaskSize = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional SchedulingMetadata scheduling_metadata = 3;
 * @return {?proto.scheduler.SchedulingMetadata}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.getSchedulingMetadata = function() {
  return /** @type{?proto.scheduler.SchedulingMetadata} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.SchedulingMetadata, 3));
};


/**
 * @param {?proto.scheduler.SchedulingMetadata|undefined} value
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
*/
proto.scheduler.EnqueueTaskReservationRequest.prototype.setSchedulingMetadata = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.clearSchedulingMetadata = function() {
  return this.setSchedulingMetadata(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.hasSchedulingMetadata = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string executor_id = 4;
 * @return {string}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.getExecutorId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.setExecutorId = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional trace.Metadata trace_metadata = 100;
 * @return {?proto.trace.Metadata}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.getTraceMetadata = function() {
  return /** @type{?proto.trace.Metadata} */ (
    jspb.Message.getWrapperField(this, proto_trace_pb.Metadata, 100));
};


/**
 * @param {?proto.trace.Metadata|undefined} value
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
*/
proto.scheduler.EnqueueTaskReservationRequest.prototype.setTraceMetadata = function(value) {
  return jspb.Message.setWrapperField(this, 100, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.EnqueueTaskReservationRequest} returns this
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.clearTraceMetadata = function() {
  return this.setTraceMetadata(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.EnqueueTaskReservationRequest.prototype.hasTraceMetadata = function() {
  return jspb.Message.getField(this, 100) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.EnqueueTaskReservationResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.EnqueueTaskReservationResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.EnqueueTaskReservationResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.EnqueueTaskReservationResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.EnqueueTaskReservationResponse}
 */
proto.scheduler.EnqueueTaskReservationResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.EnqueueTaskReservationResponse;
  return proto.scheduler.EnqueueTaskReservationResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.EnqueueTaskReservationResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.EnqueueTaskReservationResponse}
 */
proto.scheduler.EnqueueTaskReservationResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTaskId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.EnqueueTaskReservationResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.EnqueueTaskReservationResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.EnqueueTaskReservationResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.EnqueueTaskReservationResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string task_id = 1;
 * @return {string}
 */
proto.scheduler.EnqueueTaskReservationResponse.prototype.getTaskId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.EnqueueTaskReservationResponse} returns this
 */
proto.scheduler.EnqueueTaskReservationResponse.prototype.setTaskId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.RegisterExecutorRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.RegisterExecutorRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.RegisterExecutorRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterExecutorRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    node: (f = msg.getNode()) && proto.scheduler.ExecutionNode.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.RegisterExecutorRequest}
 */
proto.scheduler.RegisterExecutorRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.RegisterExecutorRequest;
  return proto.scheduler.RegisterExecutorRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.RegisterExecutorRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.RegisterExecutorRequest}
 */
proto.scheduler.RegisterExecutorRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.scheduler.ExecutionNode;
      reader.readMessage(value,proto.scheduler.ExecutionNode.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.RegisterExecutorRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.RegisterExecutorRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.RegisterExecutorRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterExecutorRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.scheduler.ExecutionNode.serializeBinaryToWriter
    );
  }
};


/**
 * optional ExecutionNode node = 1;
 * @return {?proto.scheduler.ExecutionNode}
 */
proto.scheduler.RegisterExecutorRequest.prototype.getNode = function() {
  return /** @type{?proto.scheduler.ExecutionNode} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.ExecutionNode, 1));
};


/**
 * @param {?proto.scheduler.ExecutionNode|undefined} value
 * @return {!proto.scheduler.RegisterExecutorRequest} returns this
*/
proto.scheduler.RegisterExecutorRequest.prototype.setNode = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisterExecutorRequest} returns this
 */
proto.scheduler.RegisterExecutorRequest.prototype.clearNode = function() {
  return this.setNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisterExecutorRequest.prototype.hasNode = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.scheduler.ShuttingDownRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ShuttingDownRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ShuttingDownRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ShuttingDownRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ShuttingDownRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    taskIdList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ShuttingDownRequest}
 */
proto.scheduler.ShuttingDownRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ShuttingDownRequest;
  return proto.scheduler.ShuttingDownRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ShuttingDownRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ShuttingDownRequest}
 */
proto.scheduler.ShuttingDownRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addTaskId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ShuttingDownRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ShuttingDownRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ShuttingDownRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ShuttingDownRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTaskIdList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
};


/**
 * repeated string task_id = 1;
 * @return {!Array<string>}
 */
proto.scheduler.ShuttingDownRequest.prototype.getTaskIdList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.scheduler.ShuttingDownRequest} returns this
 */
proto.scheduler.ShuttingDownRequest.prototype.setTaskIdList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.scheduler.ShuttingDownRequest} returns this
 */
proto.scheduler.ShuttingDownRequest.prototype.addTaskId = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.scheduler.ShuttingDownRequest} returns this
 */
proto.scheduler.ShuttingDownRequest.prototype.clearTaskIdList = function() {
  return this.setTaskIdList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.RegisterAndStreamWorkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.RegisterAndStreamWorkRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterAndStreamWorkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    registerExecutorRequest: (f = msg.getRegisterExecutorRequest()) && proto.scheduler.RegisterExecutorRequest.toObject(includeInstance, f),
    enqueueTaskReservationResponse: (f = msg.getEnqueueTaskReservationResponse()) && proto.scheduler.EnqueueTaskReservationResponse.toObject(includeInstance, f),
    shuttingDownRequest: (f = msg.getShuttingDownRequest()) && proto.scheduler.ShuttingDownRequest.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest}
 */
proto.scheduler.RegisterAndStreamWorkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.RegisterAndStreamWorkRequest;
  return proto.scheduler.RegisterAndStreamWorkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.RegisterAndStreamWorkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest}
 */
proto.scheduler.RegisterAndStreamWorkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.scheduler.RegisterExecutorRequest;
      reader.readMessage(value,proto.scheduler.RegisterExecutorRequest.deserializeBinaryFromReader);
      msg.setRegisterExecutorRequest(value);
      break;
    case 2:
      var value = new proto.scheduler.EnqueueTaskReservationResponse;
      reader.readMessage(value,proto.scheduler.EnqueueTaskReservationResponse.deserializeBinaryFromReader);
      msg.setEnqueueTaskReservationResponse(value);
      break;
    case 3:
      var value = new proto.scheduler.ShuttingDownRequest;
      reader.readMessage(value,proto.scheduler.ShuttingDownRequest.deserializeBinaryFromReader);
      msg.setShuttingDownRequest(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.RegisterAndStreamWorkRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.RegisterAndStreamWorkRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterAndStreamWorkRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRegisterExecutorRequest();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.scheduler.RegisterExecutorRequest.serializeBinaryToWriter
    );
  }
  f = message.getEnqueueTaskReservationResponse();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.scheduler.EnqueueTaskReservationResponse.serializeBinaryToWriter
    );
  }
  f = message.getShuttingDownRequest();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.scheduler.ShuttingDownRequest.serializeBinaryToWriter
    );
  }
};


/**
 * optional RegisterExecutorRequest register_executor_request = 1;
 * @return {?proto.scheduler.RegisterExecutorRequest}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.getRegisterExecutorRequest = function() {
  return /** @type{?proto.scheduler.RegisterExecutorRequest} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.RegisterExecutorRequest, 1));
};


/**
 * @param {?proto.scheduler.RegisterExecutorRequest|undefined} value
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
*/
proto.scheduler.RegisterAndStreamWorkRequest.prototype.setRegisterExecutorRequest = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.clearRegisterExecutorRequest = function() {
  return this.setRegisterExecutorRequest(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.hasRegisterExecutorRequest = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional EnqueueTaskReservationResponse enqueue_task_reservation_response = 2;
 * @return {?proto.scheduler.EnqueueTaskReservationResponse}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.getEnqueueTaskReservationResponse = function() {
  return /** @type{?proto.scheduler.EnqueueTaskReservationResponse} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.EnqueueTaskReservationResponse, 2));
};


/**
 * @param {?proto.scheduler.EnqueueTaskReservationResponse|undefined} value
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
*/
proto.scheduler.RegisterAndStreamWorkRequest.prototype.setEnqueueTaskReservationResponse = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.clearEnqueueTaskReservationResponse = function() {
  return this.setEnqueueTaskReservationResponse(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.hasEnqueueTaskReservationResponse = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ShuttingDownRequest shutting_down_request = 3;
 * @return {?proto.scheduler.ShuttingDownRequest}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.getShuttingDownRequest = function() {
  return /** @type{?proto.scheduler.ShuttingDownRequest} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.ShuttingDownRequest, 3));
};


/**
 * @param {?proto.scheduler.ShuttingDownRequest|undefined} value
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
*/
proto.scheduler.RegisterAndStreamWorkRequest.prototype.setShuttingDownRequest = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisterAndStreamWorkRequest} returns this
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.clearShuttingDownRequest = function() {
  return this.setShuttingDownRequest(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisterAndStreamWorkRequest.prototype.hasShuttingDownRequest = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.RegisterAndStreamWorkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.RegisterAndStreamWorkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.RegisterAndStreamWorkResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterAndStreamWorkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    enqueueTaskReservationRequest: (f = msg.getEnqueueTaskReservationRequest()) && proto.scheduler.EnqueueTaskReservationRequest.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.RegisterAndStreamWorkResponse}
 */
proto.scheduler.RegisterAndStreamWorkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.RegisterAndStreamWorkResponse;
  return proto.scheduler.RegisterAndStreamWorkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.RegisterAndStreamWorkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.RegisterAndStreamWorkResponse}
 */
proto.scheduler.RegisterAndStreamWorkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 3:
      var value = new proto.scheduler.EnqueueTaskReservationRequest;
      reader.readMessage(value,proto.scheduler.EnqueueTaskReservationRequest.deserializeBinaryFromReader);
      msg.setEnqueueTaskReservationRequest(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.RegisterAndStreamWorkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.RegisterAndStreamWorkResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.RegisterAndStreamWorkResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisterAndStreamWorkResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEnqueueTaskReservationRequest();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.scheduler.EnqueueTaskReservationRequest.serializeBinaryToWriter
    );
  }
};


/**
 * optional EnqueueTaskReservationRequest enqueue_task_reservation_request = 3;
 * @return {?proto.scheduler.EnqueueTaskReservationRequest}
 */
proto.scheduler.RegisterAndStreamWorkResponse.prototype.getEnqueueTaskReservationRequest = function() {
  return /** @type{?proto.scheduler.EnqueueTaskReservationRequest} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.EnqueueTaskReservationRequest, 3));
};


/**
 * @param {?proto.scheduler.EnqueueTaskReservationRequest|undefined} value
 * @return {!proto.scheduler.RegisterAndStreamWorkResponse} returns this
*/
proto.scheduler.RegisterAndStreamWorkResponse.prototype.setEnqueueTaskReservationRequest = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisterAndStreamWorkResponse} returns this
 */
proto.scheduler.RegisterAndStreamWorkResponse.prototype.clearEnqueueTaskReservationRequest = function() {
  return this.setEnqueueTaskReservationRequest(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisterAndStreamWorkResponse.prototype.hasEnqueueTaskReservationRequest = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.ExecutionNode.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.ExecutionNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.ExecutionNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ExecutionNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    host: jspb.Message.getFieldWithDefault(msg, 1, ""),
    port: jspb.Message.getFieldWithDefault(msg, 2, 0),
    assignableMemoryBytes: jspb.Message.getFieldWithDefault(msg, 3, 0),
    assignableMilliCpu: jspb.Message.getFieldWithDefault(msg, 4, 0),
    os: jspb.Message.getFieldWithDefault(msg, 5, ""),
    arch: jspb.Message.getFieldWithDefault(msg, 6, ""),
    pool: jspb.Message.getFieldWithDefault(msg, 7, ""),
    version: jspb.Message.getFieldWithDefault(msg, 8, ""),
    executorId: jspb.Message.getFieldWithDefault(msg, 9, ""),
    executorHostId: jspb.Message.getFieldWithDefault(msg, 10, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.ExecutionNode}
 */
proto.scheduler.ExecutionNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.ExecutionNode;
  return proto.scheduler.ExecutionNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.ExecutionNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.ExecutionNode}
 */
proto.scheduler.ExecutionNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setHost(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setPort(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAssignableMemoryBytes(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAssignableMilliCpu(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setOs(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setArch(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setPool(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersion(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutorId(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.setExecutorHostId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.ExecutionNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.ExecutionNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.ExecutionNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.ExecutionNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHost();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPort();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getAssignableMemoryBytes();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getAssignableMilliCpu();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getOs();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getArch();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getPool();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getVersion();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getExecutorId();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
  f = message.getExecutorHostId();
  if (f.length > 0) {
    writer.writeString(
      10,
      f
    );
  }
};


/**
 * optional string host = 1;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getHost = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setHost = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int32 port = 2;
 * @return {number}
 */
proto.scheduler.ExecutionNode.prototype.getPort = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setPort = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 assignable_memory_bytes = 3;
 * @return {number}
 */
proto.scheduler.ExecutionNode.prototype.getAssignableMemoryBytes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setAssignableMemoryBytes = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int64 assignable_milli_cpu = 4;
 * @return {number}
 */
proto.scheduler.ExecutionNode.prototype.getAssignableMilliCpu = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setAssignableMilliCpu = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional string os = 5;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getOs = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setOs = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional string arch = 6;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getArch = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setArch = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};


/**
 * optional string pool = 7;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getPool = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setPool = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional string version = 8;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setVersion = function(value) {
  return jspb.Message.setProto3StringField(this, 8, value);
};


/**
 * optional string executor_id = 9;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getExecutorId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setExecutorId = function(value) {
  return jspb.Message.setProto3StringField(this, 9, value);
};


/**
 * optional string executor_host_id = 10;
 * @return {string}
 */
proto.scheduler.ExecutionNode.prototype.getExecutorHostId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.ExecutionNode} returns this
 */
proto.scheduler.ExecutionNode.prototype.setExecutorHostId = function(value) {
  return jspb.Message.setProto3StringField(this, 10, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.GetExecutionNodesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.GetExecutionNodesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.GetExecutionNodesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    requestContext: (f = msg.getRequestContext()) && proto_context_pb.RequestContext.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.GetExecutionNodesRequest}
 */
proto.scheduler.GetExecutionNodesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.GetExecutionNodesRequest;
  return proto.scheduler.GetExecutionNodesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.GetExecutionNodesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.GetExecutionNodesRequest}
 */
proto.scheduler.GetExecutionNodesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto_context_pb.RequestContext;
      reader.readMessage(value,proto_context_pb.RequestContext.deserializeBinaryFromReader);
      msg.setRequestContext(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.GetExecutionNodesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.GetExecutionNodesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.GetExecutionNodesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRequestContext();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto_context_pb.RequestContext.serializeBinaryToWriter
    );
  }
};


/**
 * optional context.RequestContext request_context = 1;
 * @return {?proto.context.RequestContext}
 */
proto.scheduler.GetExecutionNodesRequest.prototype.getRequestContext = function() {
  return /** @type{?proto.context.RequestContext} */ (
    jspb.Message.getWrapperField(this, proto_context_pb.RequestContext, 1));
};


/**
 * @param {?proto.context.RequestContext|undefined} value
 * @return {!proto.scheduler.GetExecutionNodesRequest} returns this
*/
proto.scheduler.GetExecutionNodesRequest.prototype.setRequestContext = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.GetExecutionNodesRequest} returns this
 */
proto.scheduler.GetExecutionNodesRequest.prototype.clearRequestContext = function() {
  return this.setRequestContext(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.GetExecutionNodesRequest.prototype.hasRequestContext = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.scheduler.GetExecutionNodesResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.GetExecutionNodesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.GetExecutionNodesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    responseContext: (f = msg.getResponseContext()) && proto_context_pb.ResponseContext.toObject(includeInstance, f),
    executorList: jspb.Message.toObjectList(msg.getExecutorList(),
    proto.scheduler.GetExecutionNodesResponse.Executor.toObject, includeInstance),
    userOwnedExecutorsSupported: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.GetExecutionNodesResponse}
 */
proto.scheduler.GetExecutionNodesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.GetExecutionNodesResponse;
  return proto.scheduler.GetExecutionNodesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.GetExecutionNodesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.GetExecutionNodesResponse}
 */
proto.scheduler.GetExecutionNodesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto_context_pb.ResponseContext;
      reader.readMessage(value,proto_context_pb.ResponseContext.deserializeBinaryFromReader);
      msg.setResponseContext(value);
      break;
    case 2:
      var value = new proto.scheduler.GetExecutionNodesResponse.Executor;
      reader.readMessage(value,proto.scheduler.GetExecutionNodesResponse.Executor.deserializeBinaryFromReader);
      msg.addExecutor(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUserOwnedExecutorsSupported(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.GetExecutionNodesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.GetExecutionNodesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getResponseContext();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto_context_pb.ResponseContext.serializeBinaryToWriter
    );
  }
  f = message.getExecutorList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.scheduler.GetExecutionNodesResponse.Executor.serializeBinaryToWriter
    );
  }
  f = message.getUserOwnedExecutorsSupported();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.GetExecutionNodesResponse.Executor.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.GetExecutionNodesResponse.Executor} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesResponse.Executor.toObject = function(includeInstance, msg) {
  var f, obj = {
    node: (f = msg.getNode()) && proto.scheduler.ExecutionNode.toObject(includeInstance, f),
    isDefault: jspb.Message.getBooleanFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.GetExecutionNodesResponse.Executor;
  return proto.scheduler.GetExecutionNodesResponse.Executor.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.GetExecutionNodesResponse.Executor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.scheduler.ExecutionNode;
      reader.readMessage(value,proto.scheduler.ExecutionNode.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsDefault(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.GetExecutionNodesResponse.Executor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.GetExecutionNodesResponse.Executor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.GetExecutionNodesResponse.Executor.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.scheduler.ExecutionNode.serializeBinaryToWriter
    );
  }
  f = message.getIsDefault();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional ExecutionNode node = 1;
 * @return {?proto.scheduler.ExecutionNode}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.getNode = function() {
  return /** @type{?proto.scheduler.ExecutionNode} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.ExecutionNode, 1));
};


/**
 * @param {?proto.scheduler.ExecutionNode|undefined} value
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor} returns this
*/
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.setNode = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor} returns this
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.clearNode = function() {
  return this.setNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.hasNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool is_default = 2;
 * @return {boolean}
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.getIsDefault = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor} returns this
 */
proto.scheduler.GetExecutionNodesResponse.Executor.prototype.setIsDefault = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional context.ResponseContext response_context = 1;
 * @return {?proto.context.ResponseContext}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.getResponseContext = function() {
  return /** @type{?proto.context.ResponseContext} */ (
    jspb.Message.getWrapperField(this, proto_context_pb.ResponseContext, 1));
};


/**
 * @param {?proto.context.ResponseContext|undefined} value
 * @return {!proto.scheduler.GetExecutionNodesResponse} returns this
*/
proto.scheduler.GetExecutionNodesResponse.prototype.setResponseContext = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.GetExecutionNodesResponse} returns this
 */
proto.scheduler.GetExecutionNodesResponse.prototype.clearResponseContext = function() {
  return this.setResponseContext(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.hasResponseContext = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated Executor executor = 2;
 * @return {!Array<!proto.scheduler.GetExecutionNodesResponse.Executor>}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.getExecutorList = function() {
  return /** @type{!Array<!proto.scheduler.GetExecutionNodesResponse.Executor>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.scheduler.GetExecutionNodesResponse.Executor, 2));
};


/**
 * @param {!Array<!proto.scheduler.GetExecutionNodesResponse.Executor>} value
 * @return {!proto.scheduler.GetExecutionNodesResponse} returns this
*/
proto.scheduler.GetExecutionNodesResponse.prototype.setExecutorList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.scheduler.GetExecutionNodesResponse.Executor=} opt_value
 * @param {number=} opt_index
 * @return {!proto.scheduler.GetExecutionNodesResponse.Executor}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.addExecutor = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.scheduler.GetExecutionNodesResponse.Executor, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.scheduler.GetExecutionNodesResponse} returns this
 */
proto.scheduler.GetExecutionNodesResponse.prototype.clearExecutorList = function() {
  return this.setExecutorList([]);
};


/**
 * optional bool user_owned_executors_supported = 3;
 * @return {boolean}
 */
proto.scheduler.GetExecutionNodesResponse.prototype.getUserOwnedExecutorsSupported = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.scheduler.GetExecutionNodesResponse} returns this
 */
proto.scheduler.GetExecutionNodesResponse.prototype.setUserOwnedExecutorsSupported = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.scheduler.RegisteredExecutionNode.prototype.toObject = function(opt_includeInstance) {
  return proto.scheduler.RegisteredExecutionNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.scheduler.RegisteredExecutionNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisteredExecutionNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    registration: (f = msg.getRegistration()) && proto.scheduler.ExecutionNode.toObject(includeInstance, f),
    schedulerHostPort: jspb.Message.getFieldWithDefault(msg, 2, ""),
    groupId: jspb.Message.getFieldWithDefault(msg, 3, ""),
    acl: (f = msg.getAcl()) && proto_acl_pb.ACL.toObject(includeInstance, f),
    lastPingTime: (f = msg.getLastPingTime()) && google_protobuf_timestamp_pb.Timestamp.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.scheduler.RegisteredExecutionNode}
 */
proto.scheduler.RegisteredExecutionNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.scheduler.RegisteredExecutionNode;
  return proto.scheduler.RegisteredExecutionNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.scheduler.RegisteredExecutionNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.scheduler.RegisteredExecutionNode}
 */
proto.scheduler.RegisteredExecutionNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.scheduler.ExecutionNode;
      reader.readMessage(value,proto.scheduler.ExecutionNode.deserializeBinaryFromReader);
      msg.setRegistration(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSchedulerHostPort(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setGroupId(value);
      break;
    case 4:
      var value = new proto_acl_pb.ACL;
      reader.readMessage(value,proto_acl_pb.ACL.deserializeBinaryFromReader);
      msg.setAcl(value);
      break;
    case 5:
      var value = new google_protobuf_timestamp_pb.Timestamp;
      reader.readMessage(value,google_protobuf_timestamp_pb.Timestamp.deserializeBinaryFromReader);
      msg.setLastPingTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.scheduler.RegisteredExecutionNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.scheduler.RegisteredExecutionNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.scheduler.RegisteredExecutionNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.scheduler.RegisteredExecutionNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRegistration();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.scheduler.ExecutionNode.serializeBinaryToWriter
    );
  }
  f = message.getSchedulerHostPort();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getGroupId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAcl();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto_acl_pb.ACL.serializeBinaryToWriter
    );
  }
  f = message.getLastPingTime();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      google_protobuf_timestamp_pb.Timestamp.serializeBinaryToWriter
    );
  }
};


/**
 * optional ExecutionNode registration = 1;
 * @return {?proto.scheduler.ExecutionNode}
 */
proto.scheduler.RegisteredExecutionNode.prototype.getRegistration = function() {
  return /** @type{?proto.scheduler.ExecutionNode} */ (
    jspb.Message.getWrapperField(this, proto.scheduler.ExecutionNode, 1));
};


/**
 * @param {?proto.scheduler.ExecutionNode|undefined} value
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
*/
proto.scheduler.RegisteredExecutionNode.prototype.setRegistration = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
 */
proto.scheduler.RegisteredExecutionNode.prototype.clearRegistration = function() {
  return this.setRegistration(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisteredExecutionNode.prototype.hasRegistration = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string scheduler_host_port = 2;
 * @return {string}
 */
proto.scheduler.RegisteredExecutionNode.prototype.getSchedulerHostPort = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
 */
proto.scheduler.RegisteredExecutionNode.prototype.setSchedulerHostPort = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string group_id = 3;
 * @return {string}
 */
proto.scheduler.RegisteredExecutionNode.prototype.getGroupId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
 */
proto.scheduler.RegisteredExecutionNode.prototype.setGroupId = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional acl.ACL acl = 4;
 * @return {?proto.acl.ACL}
 */
proto.scheduler.RegisteredExecutionNode.prototype.getAcl = function() {
  return /** @type{?proto.acl.ACL} */ (
    jspb.Message.getWrapperField(this, proto_acl_pb.ACL, 4));
};


/**
 * @param {?proto.acl.ACL|undefined} value
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
*/
proto.scheduler.RegisteredExecutionNode.prototype.setAcl = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
 */
proto.scheduler.RegisteredExecutionNode.prototype.clearAcl = function() {
  return this.setAcl(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisteredExecutionNode.prototype.hasAcl = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional google.protobuf.Timestamp last_ping_time = 5;
 * @return {?proto.google.protobuf.Timestamp}
 */
proto.scheduler.RegisteredExecutionNode.prototype.getLastPingTime = function() {
  return /** @type{?proto.google.protobuf.Timestamp} */ (
    jspb.Message.getWrapperField(this, google_protobuf_timestamp_pb.Timestamp, 5));
};


/**
 * @param {?proto.google.protobuf.Timestamp|undefined} value
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
*/
proto.scheduler.RegisteredExecutionNode.prototype.setLastPingTime = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.scheduler.RegisteredExecutionNode} returns this
 */
proto.scheduler.RegisteredExecutionNode.prototype.clearLastPingTime = function() {
  return this.setLastPingTime(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.scheduler.RegisteredExecutionNode.prototype.hasLastPingTime = function() {
  return jspb.Message.getField(this, 5) != null;
};


goog.object.extend(exports, proto.scheduler);
